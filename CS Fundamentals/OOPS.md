Object Oriented Programming Language => https://whimsical.com/object-oriented-programming-cheatsheet-by-love-babbar-YbSgLatbWQ4R5paV7EgqFw

Follow the above roadmap

OOPs video lectures for java => kunal kushwaha

## What is Object-Oriented Programming (OOP)?

**Object-Oriented Programming (OOP)** is a ==programming paradigm== that uses the concept of **classes** and **objects** to structure software programs into reusable and modular pieces of code. This approach allows developers to model real-world entities and their interactions in a more intuitive and organized manner[1](https://www.bing.com/ck/a?!&&p=85c85436eb075c8c54b1cf653045c4070f11fb5cc3e3201cccabffc9b1c2a2c7JmltdHM9MTc0OTk0NTYwMA&ptn=3&ver=2&hsh=4&fclid=34af192e-7b97-66dd-1e82-0c437a9167bd&psq=what+is+object+oriented+programming&u=a1aHR0cHM6Ly93d3cuZWR1Y2F0aXZlLmlvL2Jsb2cvb2JqZWN0LW9yaWVudGVkLXByb2dyYW1taW5n&ntb=1).

Key Concepts of OOP

Classes and Objects

- **Class**: A class is a blueprint for creating objects. It defines the attributes (data) and methods (functions) that the objects created from the class will have. For example, a _Car_ class might have attributes like _color_, _brand_, and _model_, and methods like _drive()_ and _stop()_[1](https://www.bing.com/ck/a?!&&p=85c85436eb075c8c54b1cf653045c4070f11fb5cc3e3201cccabffc9b1c2a2c7JmltdHM9MTc0OTk0NTYwMA&ptn=3&ver=2&hsh=4&fclid=34af192e-7b97-66dd-1e82-0c437a9167bd&psq=what+is+object+oriented+programming&u=a1aHR0cHM6Ly93d3cuZWR1Y2F0aXZlLmlvL2Jsb2cvb2JqZWN0LW9yaWVudGVkLXByb2dyYW1taW5n&ntb=1).
    
- **Object**: An object is an instance of a class. It represents a specific example of the class with its own unique values for the attributes. For example, _myCar_ could be an object of the _Car_ class with specific values for _color_, _brand_, and _model_[2](https://www.bing.com/ck/a?!&&p=28eeabbba42f12e79c647131b2db4ecbd82a1cc17531d268fffe39cec9428310JmltdHM9MTc0OTk0NTYwMA&ptn=3&ver=2&hsh=4&fclid=34af192e-7b97-66dd-1e82-0c437a9167bd&psq=what+is+object+oriented+programming&u=a1aHR0cHM6Ly93d3cuZ2Vla3Nmb3JnZWVrcy5vcmcvaW50cm9kdWN0aW9uLW9mLW9iamVjdC1vcmllbnRlZC1wcm9ncmFtbWluZy8&ntb=1).

class is  **logical construct** is a **conceptual tool** or **abstract structure** created using **reasoning or logic** to help describe, explain, or organize a system — especially in fields like programming, mathematics, or philosophy.

object occupies some space in memory it is a physical reality.

Four Principles of OOP

1. **Encapsulation**: Encapsulation is the practice of wrapping data and methods that operate on the data within a single unit, typically a class. This helps protect the data from unauthorized access and modification[2](https://www.bing.com/ck/a?!&&p=6fb45dfa6a3059ca73bd795f651bccb7d53e3aab88f490d959a26fa7b52537f5JmltdHM9MTc0OTk0NTYwMA&ptn=3&ver=2&hsh=4&fclid=34af192e-7b97-66dd-1e82-0c437a9167bd&u=a1aHR0cHM6Ly93d3cuZ2Vla3Nmb3JnZWVrcy5vcmcvaW50cm9kdWN0aW9uLW9mLW9iamVjdC1vcmllbnRlZC1wcm9ncmFtbWluZy8&ntb=1).
    
2. **Inheritance**: Inheritance allows a class to inherit attributes and methods from another class. This promotes code reuse and establishes a hierarchical relationship between classes. For example, a _SportsCar_ class might inherit from the _Car_ class[2](https://www.bing.com/ck/a?!&&p=6fb45dfa6a3059ca73bd795f651bccb7d53e3aab88f490d959a26fa7b52537f5JmltdHM9MTc0OTk0NTYwMA&ptn=3&ver=2&hsh=4&fclid=34af192e-7b97-66dd-1e82-0c437a9167bd&u=a1aHR0cHM6Ly93d3cuZ2Vla3Nmb3JnZWVrcy5vcmcvaW50cm9kdWN0aW9uLW9mLW9iamVjdC1vcmllbnRlZC1wcm9ncmFtbWluZy8&ntb=1).
    
3. **Polymorphism**: Polymorphism allows objects of different classes to be treated as objects of a common superclass. It enables a single interface to represent different underlying forms (data types). For example, a method _drive()_ could be implemented differently in _Car_ and _Bike_ classes[2](https://www.bing.com/ck/a?!&&p=6fb45dfa6a3059ca73bd795f651bccb7d53e3aab88f490d959a26fa7b52537f5JmltdHM9MTc0OTk0NTYwMA&ptn=3&ver=2&hsh=4&fclid=34af192e-7b97-66dd-1e82-0c437a9167bd&u=a1aHR0cHM6Ly93d3cuZ2Vla3Nmb3JnZWVrcy5vcmcvaW50cm9kdWN0aW9uLW9mLW9iamVjdC1vcmllbnRlZC1wcm9ncmFtbWluZy8&ntb=1).
    
4. **Abstraction**: Abstraction involves hiding the complex implementation details of a class and exposing only the essential features. This simplifies the interaction with the class and promotes a clear separation of concerns[2](https://www.bing.com/ck/a?!&&p=6fb45dfa6a3059ca73bd795f651bccb7d53e3aab88f490d959a26fa7b52537f5JmltdHM9MTc0OTk0NTYwMA&ptn=3&ver=2&hsh=4&fclid=34af192e-7b97-66dd-1e82-0c437a9167bd&u=a1aHR0cHM6Ly93d3cuZ2Vla3Nmb3JnZWVrcy5vcmcvaW50cm9kdWN0aW9uLW9mLW9iamVjdC1vcmllbnRlZC1wcm9ncmFtbWluZy8&ntb=1).
    

Benefits of OOP

- **Modularity**: OOP allows developers to break down complex problems into smaller, manageable pieces by creating classes and objects[1](https://www.bing.com/ck/a?!&&p=dd950839cc6aa9156f27fff73bc79e0ae4857d99947a982b408e17b18fca7713JmltdHM9MTc0OTk0NTYwMA&ptn=3&ver=2&hsh=4&fclid=34af192e-7b97-66dd-1e82-0c437a9167bd&u=a1aHR0cHM6Ly93d3cuZWR1Y2F0aXZlLmlvL2Jsb2cvb2JqZWN0LW9yaWVudGVkLXByb2dyYW1taW5n&ntb=1).
    
- **Reusability**: Classes and objects can be reused across different programs, reducing redundancy and improving efficiency[1](https://www.bing.com/ck/a?!&&p=dd950839cc6aa9156f27fff73bc79e0ae4857d99947a982b408e17b18fca7713JmltdHM9MTc0OTk0NTYwMA&ptn=3&ver=2&hsh=4&fclid=34af192e-7b97-66dd-1e82-0c437a9167bd&u=a1aHR0cHM6Ly93d3cuZWR1Y2F0aXZlLmlvL2Jsb2cvb2JqZWN0LW9yaWVudGVkLXByb2dyYW1taW5n&ntb=1).
    
- **Maintainability**: OOP makes it easier to maintain and update code by encapsulating related data and methods within classes[2](https://www.bing.com/ck/a?!&&p=6fb45dfa6a3059ca73bd795f651bccb7d53e3aab88f490d959a26fa7b52537f5JmltdHM9MTc0OTk0NTYwMA&ptn=3&ver=2&hsh=4&fclid=34af192e-7b97-66dd-1e82-0c437a9167bd&u=a1aHR0cHM6Ly93d3cuZ2Vla3Nmb3JnZWVrcy5vcmcvaW50cm9kdWN0aW9uLW9mLW9iamVjdC1vcmllbnRlZC1wcm9ncmFtbWluZy8&ntb=1).
    
- **Scalability**: OOP supports the creation of scalable and extensible software systems by promoting code reuse and modularity[1](https://www.bing.com/ck/a?!&&p=dd950839cc6aa9156f27fff73bc79e0ae4857d99947a982b408e17b18fca7713JmltdHM9MTc0OTk0NTYwMA&ptn=3&ver=2&hsh=4&fclid=34af192e-7b97-66dd-1e82-0c437a9167bd&u=a1aHR0cHM6Ly93d3cuZWR1Y2F0aXZlLmlvL2Jsb2cvb2JqZWN0LW9yaWVudGVkLXByb2dyYW1taW5n&ntb=1).

## Static var and instance var

static variables share the same copy, no matter how many object you create and try to access it.

```java
package StaticVar;

  

public class Demo {

    static int x = 10;

  

    static void display() {

        System.out.println(x);

    }

}

  

class Test {

    public static void main(String[] args) {

        Demo obj1 = new Demo();

        Demo obj2 = new Demo();

  

        ++obj1.x;

  

        System.out.println("X in object 1");

        obj1.display();

        System.out.println("X in object 2");

        obj2.display();

    }

}
```

instance variable will have different copy for every object created.

```java
package InstanceVar;

  

public class Demo {

    int x = 10;

  

    void display() {

        System.out.println(x);

    }

}

  

class Test {

    public static void main(String[] args) {

        Demo obj1 = new Demo();

        Demo obj2 = new Demo();

  

        ++obj1.x;

  

        System.out.println("X in object 1");

        obj1.display();

        System.out.println("X in obj 2");

        obj2.display();

  

    }

}
```

## instance variables and instance methods 
if a variable is a part of a class it will be a instance variable, and the behaviours of the class or the methods will be instance methods.

```java
Instance obj = new Instance(); 
```
here obj is a reference variable because this line new Instance() created a object of the class Instance in the heap memory and the obj is the reference to that object.

new keyword allows dynamic memory allocation, allocating memory at runtime

**Instantiation** means **creating an object of a class** using the `new` keyword.  
This process **dynamically allocates memory** for the object **in the heap memory** during runtime.

for accessing the properties fields behavoiurs methods we use . operator

## Class vs Objects

- **Class**: A **blueprint** or **template** for creating objects. It defines **properties (attributes)** and **behaviors (methods)**.
- **Object**: A **real, usable entity** created based on the class. It is an **instance** of the class, meaning it has actual values for the properties defined in the class and can perform the behaviors.

## this keyword

what i understood is that i can return object for current class
When you use `return this;` inside a method, you're returning the **current object** — that is, the current instance of the class the method was called on.

```java
package ThisKeyword;

  

public class This {

    int noOfWheel;

    float currentFuel;

    String color;

    float maxSpeed;

    int noOfSeats; // instance variables or properties

  

    public This drive() {

        System.out.println("Car is driving");

        currentFuel--;

        return this;

    }

  

    public void addFuel(float fuel) {

        currentFuel += fuel;
        this.currentFuel += fuel;

    }

  

    public float getCurrentFuelLevel() {

        return currentFuel;

    }

  

    public static void main(String[] args) {

        This obj = new This();

        obj.currentFuel = 103.0f;

        This car = obj.drive().drive().drive();

        car.addFuel(1.2f);

        float result = car.getCurrentFuelLevel();

        System.out.println(result);

    }

}
```

this is basically the reference to the object of present class when and object is created a reference is also created which can not be seen that is this only 
# I got to know one in objects syntax in java

lets say we have an instance method and we create an instance of an class then we can use the reference variable with the methods name like this if we want to call it multiple times

```java
obj.methodName().methodName().methodName()
```

I found this so dope man this is known as `method-chaining`.
# static
we already know that static variables belong to class every instance of a class created can use it with the same copy for other instances of the class and methods is just you can use it without creating the object also static members cannot directly access the non static members of a class also there is a static code block that is executed only once when a class is loaded also ==one thing is that may be we cannot access non static members of a class using static things but we can access them through the instance.== Inner classes can also be static 

## Why This Matters

The `static` keyword for inner classes is about **relationship to the outer class**, not about accessing from static methods.

### Inner Class Rules:

- **Non-static inner class**: Needs an instance of the outer class to exist
- **Static inner class**: Can exist independently of the outer class

### Separate Class Rules:

- **Top-level classes**: Always independent, never need `static` keyword

```java
// Scenario 1: Non-static inner class
public class Main {
    static void staticMethod() {
        // To create non-static inner class from static context:
        Main mainObj = new Main();           // Need outer class instance first
        Students student = mainObj.new Students(); // Then create inner class
    }
    
    class Students { } // Non-static inner - tied to Main instance
}

// Scenario 2: Static inner class  
public class Main {
    static void staticMethod() {
        Students student = new Students(); // Direct creation - no outer instance needed
    }
    
    static class Students { } // Static inner - independent of Main instance
}

// Scenario 3: Separate class (your current code)
public class Main {
    static void staticMethod() {
        Students student = new Students(); // Direct creation - completely separate class
    }
}
class Students { } // Separate class - always independent
```

# Constructor

```java
package Challenge9;

  

public class Book {

    static int totalBooks;

    String title;

    String author;

    int isbn;

    boolean borrowBook = false;

  

    static {

        totalBooks = 0;

    }

  

    {

        totalBooks++;

    }

  

    Book() {

        title = "Unknown";

        author = "Unknown";

        isbn = 0;

    }

  

    Book(int isbn) {

        this.isbn = isbn;

        author = "Saad";

        title = "rdr";

    }

  

    Book(String title, String author, int isbn) {

        this.title = title;

        this.author = author;

        this.isbn = isbn;

    }

  

    static int getTotalNoOfBooks() {

        return totalBooks;

    }

  

    void borrowBook() {

        if (borrowBook) {

            System.out.println("Book is already borrowed");

        } else {

            borrowBook = true;

            System.out.println("Book borrowed");

        }

    }

  

    void returnBook() {

        if (borrowBook) {

            borrowBook = false;

            System.out.println("book returned");

        } else {

            System.out.println("Book is not borrowed");

        }

    }

  

    public static void main(String[] args) {

        Book obj = new Book();

        // obj.author = "Saif Ali Khan";

        // // obj.title = "MC";

        obj.isbn = 123;

        obj.borrowBook();

        System.out.println(obj.author + obj.title + obj.isbn);

        System.out.println(getTotalNoOfBooks());

        obj.returnBook();

    }

}
```

Constructor has same name as class it can be default or parameterized we cannot used this in a static reference because it does not has an instance but can use class name because static memebers are part of class we can also do constructor chaining call constructor from another constructor

```java
Book(int isbn) {

        this.isbn = isbn;

        author = "Saad";

        title = "rdr";

    }
    Book() {
      this("1"); // isbn
    }
```

In Java, a **copy constructor** is a constructor that creates a new object by copying the fields of another object of the same class.

```java
class ClassName {
    // Fields
    int x;
    String y;

    // Regular constructor
    ClassName(int x, String y) {
        this.x = x;
        this.y = y;
    }

    // ✅ Copy constructor
    ClassName(ClassName other) {
        this.x = other.x;
        this.y = other.y;
    }
}

```

- Java doesn't provide a default copy constructor — you have to define it explicitly.
    
- If your class has mutable fields (e.g., arrays, lists, custom objects), you may need to **deep copy** them inside the copy constructor.

_Deep cloning_ or _deep copying_ is the desired behavior in most cases. In the deep copy, we **create a clone that is independent of the original object** and making changes in the cloned object should not affect the original object.
this is called cloning in java we also have something like clonable interface clone()

# **Default Cloning via `clone()` method (Shallow Copy)**

If a class implements the `Cloneable` interface and overrides `clone()`, you can use:


```java
class Student implements Cloneable {     String name;     int age;      public Student(String name, int age) {         this.name = name;         this.age = age;     }      @Override     protected Object clone() throws CloneNotSupportedException {         return super.clone(); // shallow copy     } }
```


`Student s1 = new Student("Alice", 20); Student s2 = (Student) s1.clone();`

🔹 **Limitations**:

- `clone()` gives **shallow copy** by default.
    
- You must handle `CloneNotSupportedException`.
    
- For deep copy, override `clone()` and manually copy fields.

# Code blocks

```java
static {
}
{

}
```

static code blocks execute only once the class gets loaded
normal code block will be executed every time an instance is made.

# Access Modifiers

private, public, default, protected

public you can access any where across packages
default if we dont specify any thing to a class or the class members then it is default, it is accessible only inside a package (no modifier/ package-private )
private is acccessible only inside the class, but we can access private in a different class indirectly by creating the class object

# Getter and Setters


